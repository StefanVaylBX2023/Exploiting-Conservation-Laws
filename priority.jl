# function returns maximum exponent of variable in the ODE
function get_max_exp(xeq,var)
    xs = keys(xeq)
    map_exp = Dict{fmpq_mpoly, Int64}(x => 0 for x in xs)
    for (x,f) in xeq
        f = unpack_fraction(f)
        for variable in xs
            # TODO: commas
            # TODO: you can write max(a, b, c) in a row
            map_exp[variable] = max(map_exp[variable],degree(f[1],variable))
            map_exp[variable] = max(map_exp[variable],degree(f[2],variable))
        end
    end
    
    return map_exp[var]
end

# function returns occurence in non trivial(x1^2 doesn't count, x1^2*x2 does) monomials (monom_occur), 
# total occurence of variable (total_occur)
# and maximum coefficient of variable (max_coef)
# TODO: better naming of the function
function get_paramters(xeq, var)
    total_occur = 0
    monom_occur = 0
    max_coef = 0
    for (x,f) in xeq
        monoms = union(monomials(unpack_fraction(f)[1]), monomials(unpack_fraction(f)[2]))
        terms_ = union(terms(unpack_fraction(f)[1]), terms(unpack_fraction(f)[2]))
        for x in monoms
            if var in vars(x)
                total_occur += 1  
            end
            if (var in vars(x)) && (length(vars(x)) >=2)
                monom_occur += 1
            end
        end
        for x in terms_
            if var in vars(x) && abs(collect(coefficients(x))[1]) > max_coef
                max_coef = abs(collect(coefficients(x))[1])
            end
        end
    end
    return monom_occur, total_occur, max_coef
end

# TODO: I would put as an argument a list of functions used for ranking (get_max_exp and get_parameters) in this case
# so that one can easily add/remove/premute them
# return map from variables to their ranks
function map_var2par(ode, candidates)
    ranks = Dict()
    for x in candidates
        # TODO: you can use `get_paramters(ode, x)...`
        ranks[x] = [get_max_exp(ode,x), get_paramters(ode, x)[1], get_paramters(ode, x)[2], get_paramters(ode, x)[3]]
    end
    return ranks
end

# function returns variable with the highest priority
# TODO: better name, right now it is not clear from the name that a variables is returned, it sounds like "priority" is returned
function get_priority(mappings)
    to_compare = collect(values(mappings))
    if [to_compare[i][1] for i in 1:lastindex(to_compare)] == [0 for i in 1:lastindex(to_compare)]
        # TODO: no need to `collect`, use `first`
        return collect(keys(mappings))[1]
    end
    to_compare = [to_compare[i] for i in 1:length(to_compare) if to_compare[i][1] > 0]
    if to_compare == []
        return 0
    end
    if length(to_compare) == 1
        # TODO: use `findfirst` function
        vars = [k for (k,v) in mappings if v == to_compare[1]]
        return vars[1]
    end
    minimum = min(to_compare...)
    vars = [k for (k,v) in mappings if v == minimum]
    return vars[1]
end


# build function for this section
# TODO: also better name would be good
function find_priority(xeq,candidates)
    mappings = map_var2par(xeq, candidates)
    return get_priority(mappings)
end
