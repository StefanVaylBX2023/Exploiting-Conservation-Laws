


# adds some variable to a ring of ode and returns new ode without changes except for a ring
# TODO: change name to `add_parameter`
# TODO: to move to `ODE.jl` near `add_output`
function add_const_to_ring(ode::ODE{P}, constant) where P <: Nemo.MPolyElem
    new_var_names = vcat(collect(map(var_to_str, gens(ode.poly_ring))), constant)
    new_ring, new_vars = Nemo.PolynomialRing(Nemo.QQ, new_var_names)

    new_x_eqs = Dict{P, Union{P, Generic.Frac{P}}}(parent_ring_change(x, new_ring) => parent_ring_change(f, new_ring) for (x, f) in ode.x_equations)
    new_y_eqs = Dict{P, Union{P, Generic.Frac{P}}}(parent_ring_change(y, new_ring) => parent_ring_change(g, new_ring) for (y, g) in ode.y_equations)
    new_us = map(v -> switch_ring(v, new_ring), ode.u_vars)
    return ODE{P}(new_x_eqs, new_y_eqs, new_us)
end


# delete equation from ode 
# turns out to be unnesessary but might be useful for someone, may be deleted otherwise
# TODO: to move to `ODE.jl` and rename to `remove_unused_state`
function delete_equation(ode::ODE{P}, eq::String) where P <: Nemo.MPolyElem
    vars = collect(map(var_to_str, gens(ode.poly_ring)))
    new_var_names = [v for v in vars if v != eq]
    new_ring, new_vars = Nemo.PolynomialRing(Nemo.QQ, new_var_names)
    new_x_eqs = Dict{P, Union{P, Generic.Frac{P}}}(parent_ring_change(x, new_ring) => parent_ring_change(f, new_ring) for (x, f) in ode.x_equations if var_to_str(x) != eq)
    new_y_eqs = Dict{P, Union{P, Generic.Frac{P}}}(parent_ring_change(y, new_ring) => parent_ring_change(g, new_ring) for (y, g) in ode.y_equations if var_to_str(y) != eq)
    new_us = map(v -> switch_ring(v, new_ring), ode.u_vars)
    return ODE{P}(new_x_eqs, new_y_eqs, new_us)
end


# returns a map for solution, some kind of representation of 
# right side of the equation c = ..., where keys are vars and values are their coefficients
# TODO: a better name for a function
function find_solution(xeq)
    matrix, map_eq = matrix_constructor(xeq)
    n_col, solution_set = Nemo.nullspace(transpose(matrix))
    if (n_col == 0)
        # TODO: return `nothing`
        return 0
    end
    # TODO: better name for this variable, not clear what `set` refers to
    solution_set = transpose(solution_set)[1,:]
    # TODO: you can do with a single comprehension
    # Dict(x => solution_set[i] for (x, i) in map_eq if solution_set[i] != 0)
    solution = Dict{fmpq_mpoly,fmpq}()
    for (x,i) in map_eq
        if solution_set[i] !=0
            #println(typeof(solution_set[i]))
            solution[x] = solution_set[i]
        end
    end
    return solution
end

# function creates and apply substitution to the ODE, returns new final ODE
function construct_substitution(ode)
    new_const = gen_new_var(ode)
    ode = add_const_to_ring(ode, new_const)
    xeq = preprocess_ode(ode)
    solution = find_solution(xeq)  # find solution
    if solution == 0 #step for recursive call to stop it
        return 0
    end
    # TODO: maybe remove collect
    candidates = collect(keys(solution))
    var2sub = find_priority(ode.x_equations, candidates)
    ring = ode.poly_ring
    sub = ring(str_to_var(new_const, ode.poly_ring))
    for i in 1:length(candidates)
        if candidates[i] != var2sub
            # TODO: space around binary operations
            sub = sub - ring(candidates[i]*solution[candidates[i]])
        end
    end
    new_x = Dict()
    new_y = Dict()
    new_u = copy(ode.u_vars)
    for (x, f) in ode.x_equations
        if x != var2sub
            f = unpack_fraction(f)
            # TODO: I suggest to create a three-variable version of `make_substitution` in `utils.jl` in order not to write `one(ring)` each time 
            # TODO: define a version of `make_substitution` for fractions (maybe only the thivariate one) to be used here and below. Also in `util.jl`
            new_x[x] = make_substitution(f[1], var2sub, (1//solution[var2sub])*sub, one(ring))//make_substitution(f[2], var2sub, (1//solution[var2sub])*sub, one(ring))
        end
    end
    for (y,f) in ode.y_equations
        if y != var2sub
            f = unpack_fraction(f)
            new_y[y] = make_substitution(f[1], var2sub, (1//solution[var2sub])*sub, one(ring))//make_substitution(f[2], var2sub, (1//solution[var2sub])*sub, one(ring))
        end
    end
    # TODO: commas
    new_vars = map(var_to_str,setdiff(gens(ring),[var2sub]))
    S, _ = Nemo.PolynomialRing(Nemo.QQ, new_vars)
    dict_type = Dict{fmpq_mpoly, Union{fmpq_mpoly, Generic.Frac{fmpq_mpoly}}}
    fin_x = dict_type(parent_ring_change(x, S) => parent_ring_change(f, S) for (x,f) in new_x)
    fin_y = dict_type(parent_ring_change(y, S) => parent_ring_change(f, S) for (y,f) in new_y)
    # TODO: may be a type-inference problem for an empty array
    fin_u = [parent_ring_change(u, S) for u in new_u]
    return ODE{fmpq_mpoly}(fin_x, fin_y, fin_u)
end



#preprocess ode to return equations in denom basis
# TODO: better name, for example `clear_denominators`
function preprocess_ode(ode)
    eq2denom = Dict(x => unpack_fraction(f)[2] for (x,f) in ode.x_equations)
    ring = ode.poly_ring
    denom = lcm(collect(values(eq2denom)))
    ode_x = Dict{fmpq_mpoly, fmpq_mpoly}()
    ode_y = copy(ode.y_equations)
    ode_u = copy(ode.u_vars)
    for (x, f) in ode.x_equations
        # TODO: divexact
        multiplier = denom//eq2denom[x] #divexact
        ode_x[x] = unpack_fraction(f*denom)[1]
        
    end
    return ode_x

end

# recursive approach to apply all possible solutions
function perform_substitution(ode)
    subbed = construct_substitution(ode)
    temp = subbed
    # TODO: should this be an error?
    if subbed == 0
        error("Method is not applicable for this ODE")
    else
        while subbed != 0
            temp = subbed
            subbed = construct_substitution(subbed)
        end
    end
    return temp
end


#generate new variable name
function gen_new_var(ode::ODE{P}) where P <: fmpq_mpoly
    str = map(var_to_str, gens(ode.poly_ring))
    # TODO: remove a separate `if`. You can just do `counter = 1` and then the while-loop
    if "c1" ∉ str
        return "c1"
    else
        counter = 2
        while "c$counter" ∈ str
            counter += 1
        end
        return "c$counter"
    end
end
