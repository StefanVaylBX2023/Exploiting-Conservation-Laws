


# adds some variable to a ring of ode and returns new ode without changes except for a ring
function add_const_to_ring(ode::ODE{P}, constant) where P <: Nemo.MPolyElem
    new_var_names = vcat(collect(map(var_to_str, gens(ode.poly_ring))), constant)
    new_ring, new_vars = Nemo.PolynomialRing(Nemo.QQ, new_var_names)

    new_x_eqs = Dict{P, Union{P, Generic.Frac{P}}}(parent_ring_change(x, new_ring) => parent_ring_change(f, new_ring) for (x, f) in ode.x_equations)
    new_y_eqs = Dict{P, Union{P, Generic.Frac{P}}}(parent_ring_change(y, new_ring) => parent_ring_change(g, new_ring) for (y, g) in ode.y_equations)
    new_us = map(v -> switch_ring(v, new_ring), ode.u_vars)
    return ODE{P}(new_x_eqs, new_y_eqs, new_us)
end


# delete equation from ode
function delete_equation(ode::ODE{P}, eq::String) where P <: Nemo.MPolyElem
    #println(typeof(vcat(collect(map(var_to_str, gens(ode.poly_ring)))...)))
    vars = collect(map(var_to_str, gens(ode.poly_ring)))
    new_var_names = [v for v in vars if v != eq]
    new_ring, new_vars = Nemo.PolynomialRing(Nemo.QQ, new_var_names)
    new_x_eqs = Dict{P, Union{P, Generic.Frac{P}}}(parent_ring_change(x, new_ring) => parent_ring_change(f, new_ring) for (x, f) in ode.x_equations if var_to_str(x) != eq)
    new_y_eqs = Dict{P, Union{P, Generic.Frac{P}}}(parent_ring_change(y, new_ring) => parent_ring_change(g, new_ring) for (y, g) in ode.y_equations if var_to_str(y) != eq)
    new_us = map(v -> switch_ring(v, new_ring), ode.u_vars)
    return ODE{P}(new_x_eqs, new_y_eqs, new_us)
end


# returns a map for solution, some kind of representation of 
# right side of the equation c = ..., where keys are vars and values are their coefficients
function find_solution(xeq)
    matrix, map_eq = matrix_constructor(xeq)
    n_col, solution_set = Nemo.nullspace(transpose(matrix))
    if (n_col == 0) 
        return 0
    end
    solution_set = transpose(solution_set)[1,:]
    solution = Dict{fmpq_mpoly,fmpq}()
    for (x,i) in map_eq
        if solution_set[i] !=0
            #println(typeof(solution_set[i]))
            solution[x] = solution_set[i]
        end
    end
    return solution
end

# function creates and apply substitution to the ODE, returns new final ODE
function construct_substitution(ode)
    new_const = gen_new_var(ode)
    ode = add_const_to_ring(ode, new_const)
    ode, xeq = preprocess_ode(ode)
    solution = find_solution(xeq)
    if solution == 0
        return 0
    end
    candidates = collect(keys(solution))
    var2sub = find_priority(ode.x_equations, candidates)
    "if var2sub == 0
        return 0
    end"
    ring = ode.poly_ring
    sub = ring(str_to_var(new_const, ode.poly_ring))
    for i in 1:length(candidates)
        if candidates[i] != var2sub
            sub = sub - ring(candidates[i]*solution[candidates[i]])
        end
    end
    #println(" sub $(solution[var2sub]) * $var2sub = $sub")
    new_x = Dict()
    new_y = Dict()
    new_u = copy(ode.u_vars)
    #const1 = 1//solution[var2sub]
    #println(typeof(solution[var2sub]))
    for (x, f) in ode.x_equations
        if x != var2sub
            f = unpack_fraction(f)
            new_x[x] = make_substitution(f[1], var2sub, (1//solution[var2sub])*sub, one(ring))//make_substitution(f[2], var2sub, (1//solution[var2sub])*sub, one(ring))
        end
    end
    for (y,f) in ode.y_equations
        if y != var2sub
            f = unpack_fraction(f)
            new_y[y] = make_substitution(f[1], var2sub, (1//solution[var2sub])*sub, one(ring))//make_substitution(f[2], var2sub, (1//solution[var2sub])*sub, one(ring))
        end
    end
    #println(setdiff(gens(ring)),[var2sub])
    new_vars = map(var_to_str,setdiff(gens(ring),[var2sub]))
    S, _ = Nemo.PolynomialRing(Nemo.QQ, new_vars)
    dict_type = Dict{fmpq_mpoly, Union{fmpq_mpoly, Generic.Frac{fmpq_mpoly}}}
    fin_x = dict_type(parent_ring_change(x, S) => parent_ring_change(f, S) for (x,f) in new_x)
    fin_y = dict_type(parent_ring_change(y, S) => parent_ring_change(f, S) for (y,f) in new_y)
    fin_u = [parent_ring_change(u, S) for u in new_u]
    return ODE{fmpq_mpoly}(fin_x, fin_y, fin_u)
end


function preprocess_ode(ode)
    eq2denom = Dict(x => unpack_fraction(f)[2] for (x,f) in ode.x_equations)
    ring = ode.poly_ring
    denom = lcm(collect(values(eq2denom)))
    #println("denom = $denom")
    #println(typeof(denom))
    #if denom == 1
    #    return ode, ode.x_equations
    #end

    ode_x = Dict{fmpq_mpoly, fmpq_mpoly}()
    ode_y = copy(ode.y_equations)
    ode_u = copy(ode.u_vars)
    for (x, f) in ode.x_equations
        multiplier = denom//eq2denom[x] #divexact
        ode_x[x] = unpack_fraction(f*denom)[1]
        
    end
    return ode, ode_x

end


function perform_substitution(ode)
    #ode, coef = preprocess_ode(ode)
    subbed = construct_substitution(ode)
    temp = subbed
    if subbed == 0
        error("Method is not applicable for this ODE")
    else
        while subbed != 0
            temp = subbed
            subbed = construct_substitution(subbed)
        end
    end
    return temp
end


#generate new variable name
function gen_new_var(ode::ODE{P}) where P <: fmpq_mpoly
    str = map(var_to_str, gens(ode.poly_ring))
    if "c1" ∉ str
        return "c1"
    else
        counter = 2
        while "c$counter" ∈ str
            counter += 1
        end
        return "c$counter"
    end
end
