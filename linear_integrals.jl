


function find_all_monomials(equations::Array{fmpq_mpoly,1})
    # TODO: see the comment on the next line
    # is L is a list of sets, takin union can be done by `reduce(union, L)`, so the code below can be made more concise
    monoms = Set{fmpq_mpoly}()
    for f in equations
        # map(mon, eq)
        temp = collect(monomials(f))
        union!(monoms, temp)
    end
    return monoms
end


function matrix_constructor(xeq::Dict{fmpq_mpoly, fmpq_mpoly})
    equations = collect(values(xeq))
    monoms = find_all_monomials(equations)
    matrix = zero(Nemo.MatrixSpace(Nemo.QQ, length(xeq), length(monoms)))
    map_monom = Dict{fmpq_mpoly,Int64}(monomial => i for (i, monomial) in enumerate(monoms))
    map_eq = Dict{fmpq_mpoly, Int64}(x => i for (i, (x, f)) in enumerate(xeq))
    for (x, f) in xeq
        for term in (terms(f))
                matrix[map_eq[x], map_monom[collect(monomials(term))[1]]] = first(coefficients(term)) 
        end
    end
    return matrix, map_eq
end


# ----------------------------------------------------------------------------------------------


function get_max_exp(xeq, var)
    xs = keys(xeq)
    map_exp = Dict{fmpq_mpoly, Int64}(x => 0 for x in xs)
    for (x, f) in xeq
        f = unpack_fraction(f)
        for variable in xs
            map_exp[variable] = max(map_exp[variable], degree(f[1], variable), degree(f[2], variable))
        end
    end
    
    return map_exp[var]
end

function get_occurences(xeq, var)
    total_occur = 0
    monom_occur = 0
    max_coef = 0
    for (x, f) in xeq
        monoms = union(monomials(unpack_fraction(f)[1]), monomials(unpack_fraction(f)[2]))
        terms_ = union(terms(unpack_fraction(f)[1]), terms(unpack_fraction(f)[2]))
        for x in monoms
            if var in vars(x)
                total_occur += 1  
            end
            if (var in vars(x)) && (length(vars(x)) >=2)
                monom_occur += 1
            end
        end
        for x in terms_
            if var in vars(x) && abs(collect(coefficients(x))[1]) > max_coef
                max_coef = abs(collect(coefficients(x))[1])
            end
        end
    end
    return monom_occur, total_occur, max_coef
end

# TODO: I would put as an argument a list of functions used for ranking (get_max_exp and get_parameters) in this case
# so that one can easily add/remove/premute them
# return map from variables to their ranks
function map_var2par(ode, candidates)
    ranks = Dict()
    for x in candidates
        # TODO: you can use `get_paramters(ode, x)...`
        ranks[x] = [get_max_exp(ode, x), get_occurences(ode, x)[1], get_occurences(ode, x)[2], get_occurences(ode, x)[3]]
    end
    return ranks
end

# function returns variable with the highest priority
function find_var2sub(mappings)
    to_compare = collect(values(mappings))
    if [to_compare[i][1] for i in 1:lastindex(to_compare)] == [0 for i in 1:lastindex(to_compare)]
        return first(keys(mappings))
    end
    to_compare = [to_compare[i] for i in 1:length(to_compare) if to_compare[i][1] > 0]
    if to_compare == []
        return 0
    end
    if length(to_compare) == 1
        return findfirst(x -> x == to_compare[1], mappings)
    end
    minimum = min(to_compare...)
    vars = findfirst(x -> x == minimum, mappings)
    return vars
end


# build function for this section

function get_var2sub(xeq, candidates)
    mappings = map_var2par(xeq, candidates)
    return find_var2sub(mappings)
end


# ----------------------------------------------------------------------------------------------


# adds some variable to a ring of ode and returns new ode without changes except for a ring
# TODO: change name to `add_parameter`
# TODO: to move to `ODE.jl` near `add_output`
function add_parameter(ode::ODE{P}, constant) where P <: Nemo.MPolyElem
    new_var_names = vcat(collect(map(var_to_str, gens(ode.poly_ring))), constant)
    new_ring, new_vars = Nemo.PolynomialRing(Nemo.QQ, new_var_names)

    new_x_eqs = Dict{P, Union{P, Generic.Frac{P}}}(parent_ring_change(x, new_ring) => parent_ring_change(f, new_ring) for (x, f) in ode.x_equations)
    new_y_eqs = Dict{P, Union{P, Generic.Frac{P}}}(parent_ring_change(y, new_ring) => parent_ring_change(g, new_ring) for (y, g) in ode.y_equations)
    new_us = map(v -> switch_ring(v, new_ring), ode.u_vars)
    return ODE{P}(new_x_eqs, new_y_eqs, new_us)
end



function remove_unused_state(ode::ODE{P}, eq::String) where P <: Nemo.MPolyElem
    vars = collect(map(var_to_str, gens(ode.poly_ring)))
    new_var_names = [v for v in vars if v != eq]
    new_ring, new_vars = Nemo.PolynomialRing(Nemo.QQ, new_var_names)
    new_x_eqs = Dict{P, Union{P, Generic.Frac{P}}}(parent_ring_change(x, new_ring) => parent_ring_change(f, new_ring) for (x, f) in ode.x_equations if var_to_str(x) != eq)
    new_y_eqs = Dict{P, Union{P, Generic.Frac{P}}}(parent_ring_change(y, new_ring) => parent_ring_change(g, new_ring) for (y, g) in ode.y_equations if var_to_str(y) != eq)
    new_us = map(v -> switch_ring(v, new_ring), ode.u_vars)
    return ODE{P}(new_x_eqs, new_y_eqs, new_us)
end

# ----------------------------------------------------------------------------------------------

# returns a map for solution, some kind of representation of 
# right side of the equation c = ..., where keys are vars and values are their coefficients
# TODO: a better name for a function
function find_solution(xeq)
    matrix, map_eq = matrix_constructor(xeq)
    n_col, solution_set = Nemo.nullspace(transpose(matrix))
    if (n_col == 0)
        # TODO: return `nothing`
        return 0
    end
    # TODO: better name for this variable, not clear what `set` refers to
    solution_set = transpose(solution_set)[1,:]
    # TODO: you can do with a single comprehension
    # Dict(x => solution_set[i] for (x, i) in map_eq if solution_set[i] != 0)
    solution = Dict{fmpq_mpoly,fmpq}()
    for (x,i) in map_eq
        if solution_set[i] !=0
            #println(typeof(solution_set[i]))
            solution[x] = solution_set[i]
        end
    end
    return solution
end




# function creates and apply substitution to the ODE, returns new final ODE
function construct_substitution(ode)
    new_const = gen_new_var(ode)
    ode = add_parameter(ode, new_const)
    xeq = clear_denominators(ode)
    solution = find_solution(xeq)  # find solution
    if solution == 0 #step for recursive call to stop it
        return 0
    end
    # TODO: maybe remove collect
    candidates = collect(keys(solution))
    var2sub = get_var2sub(ode.x_equations, candidates)
    ring = ode.poly_ring
    sub = ring(str_to_var(new_const, ode.poly_ring))
    for i in 1:length(candidates)
        if candidates[i] != var2sub
            # TODO: space around binary operations
            sub = sub - ring(candidates[i]*solution[candidates[i]])
        end
    end
    new_x = Dict()
    new_y = Dict()
    new_u = copy(ode.u_vars)
    for (x, f) in ode.x_equations
        if x != var2sub
            f = unpack_fraction(f)
            # TODO: I suggest to create a three-variable version of `make_substitution` in `utils.jl` in order not to write `one(ring)` each time 
            # TODO: define a version of `make_substitution` for fractions (maybe only the thivariate one) to be used here and below. Also in `util.jl`
            new_x[x] = make_substitution(f[1], var2sub, (1//solution[var2sub])*sub, one(ring))//make_substitution(f[2], var2sub, (1//solution[var2sub])*sub, one(ring))
        end
    end
    for (y,f) in ode.y_equations
        if y != var2sub
            f = unpack_fraction(f)
            new_y[y] = make_substitution(f[1], var2sub, (1//solution[var2sub])*sub, one(ring))//make_substitution(f[2], var2sub, (1//solution[var2sub])*sub, one(ring))
        end
    end
    # TODO: commas
    new_vars = map(var_to_str,setdiff(gens(ring),[var2sub]))
    S, _ = Nemo.PolynomialRing(Nemo.QQ, new_vars)
    dict_type = Dict{fmpq_mpoly, Union{fmpq_mpoly, Generic.Frac{fmpq_mpoly}}}
    fin_x = dict_type(parent_ring_change(x, S) => parent_ring_change(f, S) for (x,f) in new_x)
    fin_y = dict_type(parent_ring_change(y, S) => parent_ring_change(f, S) for (y,f) in new_y)
    # TODO: may be a type-inference problem for an empty array
    fin_u = [parent_ring_change(u, S) for u in new_u]
    return ODE{fmpq_mpoly}(fin_x, fin_y, fin_u)
end



#preprocess ode to return equations in denom basis
# TODO: better name, for example `clear_denominators`
function clear_denominators(ode)
    eq2denom = Dict(x => unpack_fraction(f)[2] for (x,f) in ode.x_equations)
    ring = ode.poly_ring
    denom = lcm(collect(values(eq2denom)))
    ode_x = Dict{fmpq_mpoly, fmpq_mpoly}()
    ode_y = copy(ode.y_equations)
    ode_u = copy(ode.u_vars)
    for (x, f) in ode.x_equations
        # TODO: divexact
        multiplier = denom//eq2denom[x] #divexact
        ode_x[x] = unpack_fraction(f*denom)[1]
        
    end
    return ode_x

end

# recursive approach to apply all possible solutions
function perform_substitution(ode)
    subbed = construct_substitution(ode)
    temp = subbed
    # TODO: should this be an error?
    if subbed == 0
        error("Method is not applicable for this ODE")
    else
        while subbed != 0
            temp = subbed
            subbed = construct_substitution(subbed)
        end
    end
    return temp
end


#generate new variable name
function gen_new_var(ode::ODE{P}) where P <: fmpq_mpoly
    str = map(var_to_str, gens(ode.poly_ring))
    # TODO: remove a separate `if`. You can just do `counter = 1` and then the while-loop
    if "c1" ∉ str
        return "c1"
    else
        counter = 2
        while "c$counter" ∈ str
            counter += 1
        end
        return "c$counter"
    end
end
