# return all monomials in the ODE
function find_all_monomials(xeq)
    # is L is a list of sets, takin union can be done by `reduce(union, L)`, so the code below can be made more concise
    monoms = Set{fmpq_mpoly}()
    for (x,f) in xeq
        temp = collect(monomials(f))
        union!(monoms, temp)
    end
    return monoms
end


#create zero matrix with the right dimensions (number of equations x number of monomials )
function create_matrix(monoms, xeq)
    
    S = Nemo.MatrixSpace(Nemo.QQ, length(collect(values(xeq))), length(monoms))
    
    return zero(S)
end


# create a mappings which further will be used to fill the matrix with coefficients
function matrix_legend(monoms, xeq)
    
    map_monom = Dict(monomial => i for (i,monomial) in enumerate(monoms))
    map_eq = Dict{fmpq_mpoly, Int64}(x => i for (i,(x,f)) in enumerate(xeq))
  
    return map_eq, map_monom
end

# fill the matrix with coefficients
function fill_matrix(xeq, matrix, map_eq, map_monom)
    
    #println(map_eq)
    #println(map_monom)
    for (x,f) in xeq
        # do you really need `collect` here
        for term in (terms(f))
                matrix[map_eq[x],map_monom[collect(monomials(term))[1]]] = collect(coefficients(term))[1] # = first(coefficients(term))
        end
    end
    return matrix
end


function matrix_constructor(xeq)
    #xeq = ode.x_equations
    monoms = find_all_monomials(xeq)
    matrix = create_matrix(monoms, xeq)
    map_eq, map_monom = matrix_legend(monoms, xeq)
    matrix = fill_matrix(xeq, matrix, map_eq, map_monom)
    return matrix, map_eq
end
